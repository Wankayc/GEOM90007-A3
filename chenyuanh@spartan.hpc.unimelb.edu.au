// psort.c
#include "psort.h"
#include "router.h"   // ByteVec, router_alltoallv, bv_*
#include "format.h"   // Line, format_line_string, free_line
#include <mpi.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#ifdef USE_OMP
#include <omp.h>
#endif

// splitter key used during sample sort
typedef struct { uint16_t nc; char* word; } Key;

// order by (nc, word)
static int cmp_key(const void* a, const void* b){
    const Key* A = (const Key*)a; const Key* B = (const Key*)b;
    if (A->nc < B->nc) return -1;
    if (A->nc > B->nc) return  1;
    return strcmp(A->word, B->word);
}

// Key比較函式，用於qsort
static int cmp_serialized_key(const void* a, const void* b) {
    const Key* ka = (const Key*)a;
    const Key* kb = (const Key*)b;
    if (ka->nc < kb->nc) return -1;
    if (ka->nc > kb->nc) return 1;
    return strcmp(ka->word, kb->word);
}


// 以下替代原阻塞樣本收集的函式，改用 MPI_Gather
static int psort_collect_samples(MPI_Comm comm, int rank, int P, Line** lines, int n, Key** out_samples, int* out_nsamp) {
    int nsamp = (P > 1) ? (P - 1) : 0;
    Key* local_samples = NULL;

    if (nsamp > 0) {
        local_samples = (Key*)malloc((size_t)nsamp * sizeof(Key));
        if (!local_samples) {
            fprintf(stderr, "Rank %d malloc local_samples failed\n", rank);
            MPI_Abort(comm, 1);
        }
    }

    for (int i = 0; i < nsamp; ++i) {
        if (n == 0) {
            local_samples[i].nc = 0;
            local_samples[i].word = (char*)"";
        } else {
            int idx = (int)((long long)(i + 1) * n / P);
            if (idx >= n) idx = n - 1;
            local_samples[i].nc = lines[idx]->nc;
            local_samples[i].word = lines[idx]->word;
        }
    }

    Key* all_samples = NULL;
    int total_samples = nsamp * P;

    // 先建立方便傳送的記憶體，將 local_samples 的字串複製到 buffers
    // 因Key中有指標，無法直接傳送，改為序列化：每個Key存nc + word字串（用固定長度）
    // 以下用二維char陣列按字串長度256固定字串
    typedef struct {
        uint16_t nc;
        char word[256];
    } KeyBuffered;

    KeyBuffered* sendbuf = NULL;
    if (nsamp > 0) {
        sendbuf = (KeyBuffered*)malloc(nsamp * sizeof(KeyBuffered));
        for (int i = 0; i < nsamp; i++) {
            sendbuf[i].nc = local_samples[i].nc;
            size_t wlen = strlen(local_samples[i].word);
            if (wlen > 255) wlen = 255;
            memcpy(sendbuf[i].word, local_samples[i].word, wlen);
            sendbuf[i].word[wlen] = '\0';
        }
    }

    KeyBuffered* recvbuf = NULL;
    if (rank == 0 && total_samples > 0) {
        recvbuf = (KeyBuffered*)malloc(total_samples * sizeof(KeyBuffered));
        if (!recvbuf) {
            fprintf(stderr, "Rank 0 malloc recvbuf failed\n");
            MPI_Abort(comm, 1);
        }
    }

    MPI_Gather(sendbuf, nsamp * sizeof(KeyBuffered), MPI_BYTE,
               recvbuf, nsamp * sizeof(KeyBuffered), MPI_BYTE,
               0, comm);

    free(sendbuf);
    if (local_samples) free(local_samples);

    // Rank 0回傳完整的 Key陣列（用動態記憶體保留字串）
    if (rank == 0 && total_samples > 0) {
        all_samples = (Key*)malloc(total_samples * sizeof(Key));
        for (int i = 0; i < total_samples; i++) {
            all_samples[i].nc = recvbuf[i].nc;
            size_t wlen = strlen(recvbuf[i].word);
            all_samples[i].word = (char*)malloc(wlen + 1);
            strcpy(all_samples[i].word, recvbuf[i].word);
        }
    }
    if (recvbuf) free(recvbuf);

    *out_samples = all_samples;
    *out_nsamp = total_samples;
    return 0;
}


int psort_distribute_and_write(Line*** plines, int* pn, const char* out_path, MPI_Comm comm){
    Line** lines = *plines; int n = *pn;
    int rank, P; MPI_Comm_rank(comm, &rank); MPI_Comm_size(comm, &P);

    // --- 1) local key-sort: (nc, word)
    if (n > 1) qsort(lines, n, sizeof(Line*), cmp_line_key);

    // --- 2) format each line to a ready-to-write string (parallel & thread-safe)
    char     **line_str  = (n? (char**)calloc((size_t)n, sizeof(char*)) : NULL);
    uint32_t  *line_len  = (n? (uint32_t*)malloc((size_t)n * sizeof(uint32_t)) : NULL);
    if ((n && (!line_str || !line_len))) { perror("alloc line_str/line_len"); MPI_Abort(comm, 90); }

#ifdef USE_OMP
#pragma omp parallel for schedule(dynamic,512)
#endif
    for (int i = 0; i < n; ++i) {
        // format_line_string must malloc a buffer and return its length (may include '\n')
        line_len[i] = (uint32_t)format_line_string(lines[i], &line_str[i]);
        // ensure trailing newline for consistent byte counting
        if (line_len[i] == 0 || line_str[i][line_len[i]-1] != '\n') {
            line_str[i] = (char*)realloc(line_str[i], (size_t)line_len[i] + 2);
            line_str[i][line_len[i]++] = '\n';
            line_str[i][line_len[i]] = '\0';
        }
    }

    // --- 3) collect samples with MPI_Gather (new non-blocking safe version)
    Key* all_samp = NULL; int total_samp = 0;
    int nsamp = (P > 1 ? (P - 1) : 0);

    if (psort_collect_samples(comm, rank, P, lines, n, &all_samp, &total_samp) != 0) {
        fprintf(stderr, "Failed to collect samples in rank %d\n", rank);
        MPI_Abort(comm, 10);
    }

    // pick P-1 splitters & broadcast
    uint16_t* split_nc = NULL; int* split_wl = NULL; char** split_word = NULL;
    if (P > 1) {
        split_nc = (uint16_t*)malloc((size_t)(P - 1) * sizeof(uint16_t));
        split_wl = (int*)malloc((size_t)(P - 1) * sizeof(int));
        split_word = (char**)malloc((size_t)(P - 1) * sizeof(char*));

        if (rank == 0) {
            if (total_samp > 0) {
                qsort(all_samp, total_samp, sizeof(Key), cmp_key);
                for (int j = 0; j < P - 1; ++j) {
                    int pick = (int)((long long)(j + 1) * total_samp / P);
                    if (pick >= total_samp) pick = total_samp - 1;
                    split_nc[j] = all_samp[pick].nc;
                    split_wl[j] = (int)strlen(all_samp[pick].word);
                    split_word[j] = all_samp[pick].word; // already malloc'ed above
                }
            } else {
                for (int j = 0; j < P - 1; ++j) {
                    split_nc[j] = 0; split_wl[j] = 0; split_word[j] = (char*)"";
                }
            }
        }

        // broadcast splitter meta
        MPI_Bcast(split_nc, P - 1, MPI_UINT16_T, 0, comm);
        MPI_Bcast(split_wl, P - 1, MPI_INT, 0, comm);

        // broadcast splitter words by length
        for (int j = 0; j < P - 1; ++j) {
            if (rank != 0) {
                split_word[j] = (split_wl[j] ? (char*)malloc((size_t)split_wl[j] + 1) : (char*)"");
            }
            if (split_wl[j] > 0) {
                MPI_Bcast(split_word[j], split_wl[j], MPI_CHAR, 0, comm);
                if (rank != 0) split_word[j][split_wl[j]] = '\0';
            }
        }
    }

    if (rank == 0 && all_samp) {
        // free malloc'ed all_samp words now owned by split_word array
        for (int i = 0; i < total_samp; ++i) {
            // all_samp[i].word == pointer to malloc'ed string
            if (all_samp[i].word)
                free(all_samp[i].word);
        }
        free(all_samp);
    }

    // --- 4) partition already-formatted strings into P buckets by splitters
    ByteVec* buckets = (ByteVec*)malloc((size_t)P * sizeof(ByteVec));
    for (int d = 0; d < P; ++d) bv_init(&buckets[d]);

    for (int i = 0; i < n; ++i) {
        int dest = (P > 1) ? (P - 1) : 0;
        if (P > 1) {
            int lo = 0, hi = P - 2;
            while (lo <= hi) {
                int md = (lo + hi) >> 1;
                int cmp;
                if (lines[i]->nc < split_nc[md]) cmp = -1;
                else if (lines[i]->nc > split_nc[md]) cmp =  1;
                else cmp = strcmp(lines[i]->word, split_word[md]);
                if (cmp <= 0) { dest = md; hi = md - 1; }
                else          { lo  = md + 1; }
            }
        }
        uint16_t nc = (uint16_t)lines[i]->nc;
        uint16_t wl = (uint16_t)lines[i]->wlen;
        bv_put_u16(&buckets[dest], nc);
        bv_put_u16(&buckets[dest], wl);
        if (wl){
            bv_put(&buckets[dest], lines[i]->word, wl);
        }
        uint32_t len = (line_len ? line_len[i] : 0);
        bv_put(&buckets[dest], &len, 4);

        if (line_len && len){
            bv_put(&buckets[dest], line_str[i], (size_t)len);
        }
    }

    // release local formatted copies and original Line objects
    for (int i = 0; i < n; ++i) {
        free(line_str[i]);
    }
    free(line_str);
    free(line_len);

    if (P > 1) {
        for (int j = 0; j < P - 1; ++j) {
            if (split_wl[j] > 0) free(split_word[j]);
        }
        free(split_word);
        free(split_nc);
        free(split_wl);
    }

    // --- 5) all-to-allv exchange of final byte streams
    unsigned char* rbuf = NULL; int* rcounts = NULL, *rdispls = NULL; int rtot = 0;
    router_alltoallv(buckets, &rbuf, &rcounts, &rdispls, &rtot, comm);
    for (int d = 0; d < P; ++d) bv_free(&buckets[d]);
    free(buckets);

    // --- 6) parse payload, rebuild minimal Lines, local sort, and write MPI-IO
    Line** new_lines = NULL; int m = 0, mcap = 0;
    for (int src = 0; src < P; ++src) {
        unsigned char* p = rbuf + rdispls[src];
        unsigned char* e = p + rcounts[src];
        while (p < e) {
            if (m == mcap) { mcap = mcap ? mcap * 2 : 256; new_lines = (Line**)realloc(new_lines, (size_t)mcap * sizeof(Line*)); }
            uint16_t nc; memcpy(&nc, p, 2); p += 2;
            uint16_t wl; memcpy(&wl, p, 2); p += 2;
            char* w = (wl ? (char*)malloc((size_t)wl + 1) : NULL);
            if (wl) { memcpy(w, p, wl); p += wl; w[wl] = '\0'; }
            uint32_t ln; memcpy(&ln, p, 4); p += 4;
            char* ls = (ln ? (char*)malloc((size_t)ln + 1) : NULL);
            if (ln) { memcpy(ls, p, ln); p += ln; ls[ln] = '\0'; }


            Line* L = (Line*)calloc(1, sizeof(Line));
            L->word = w; L->wlen = wl; L->nc = nc;
            // store the already-formatted string into cands[0] to reuse write path
            L->cands = (char**)malloc(sizeof(char*));
            L->clen = (uint16_t*)malloc(sizeof(uint16_t));
            L->cands[0] = ls;
            L->clen[0] = (uint16_t)ln; // if ln > 65535, widen in Line definition
            L->nc = nc;
            new_lines[m++] = L;
        }
    }
    free(rbuf);
    free(rcounts);
    free(rdispls);

    if (m > 1) qsort(new_lines, m, sizeof(Line*), cmp_line_key);

    // compute byte counts for MPI-IO
    unsigned long long local_bytes = 0ULL;
    for (int i = 0; i < m; ++i) {
        local_bytes += (unsigned long long)new_lines[i]->clen[0];
    }
    unsigned long long file_off = 0ULL;
    MPI_Exscan(&local_bytes, &file_off, 1, MPI_UNSIGNED_LONG_LONG, MPI_SUM, comm);

    unsigned long long total_bytes = 0ULL;
    MPI_Allreduce(&local_bytes, &total_bytes, 1, MPI_UNSIGNED_LONG_LONG, MPI_SUM, comm);

    MPI_File fh;
    MPI_File_open(comm, (char*)out_path, MPI_MODE_CREATE | MPI_MODE_WRONLY, MPI_INFO_NULL, &fh);
    MPI_Offset off = (MPI_Offset)file_off;

    for (int i = 0; i < m; ++i) {
        char*    s  = new_lines[i]->cands[0];
        uint32_t ln = (uint32_t)new_lines[i]->clen[0];
        if (ln) {
            MPI_File_write_at_all(fh, off, s, (int)ln, MPI_CHAR, MPI_STATUS_IGNORE);
            off += (MPI_Offset)ln;
        }
    }
    MPI_File_close(&fh);

    // cleanup
    for (int i = 0; i < m; ++i) {
        if (new_lines[i]->cands && new_lines[i]->cands[0]) free(new_lines[i]->cands[0]);
        if (new_lines[i]->word) free(new_lines[i]->word);
        if (new_lines[i]->cands) free(new_lines[i]->cands);
        if (new_lines[i]->clen) free(new_lines[i]->clen);
        free(new_lines[i]);
    }
    free(new_lines);

    if (rank == 0) {
        fprintf(stderr, "[psort] wrote %llu bytes to %s\n",
            (unsigned long long)total_bytes, out_path);
    }

    return 0;
}
